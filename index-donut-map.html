<!DOCTYPE html>

<head>
    <meta charset="utf-8">
    <title>ClusterPies</title>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css" />
    <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/MarkerCluster.css' rel='stylesheet' />
    <link rel="stylesheet" href="clusterpies.css" />
</head>

<body>
    <script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js" charset="utf-8"></script>
    <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js'></script>
    <!-- <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->
    <script src="http://d3js.org/d3.v4.min.js" charset="utf-8"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
    <script src="http://dimplejs.org/dist/dimple.v2.3.0.min.js"></script>
    <div id="container">
        <div id="map" />
    </div>
    <script>
        "use strict"
        var geojson,
            metadata,
            geojsonPath = 'traffic_accidents.geojson',
            // injuries
            categoryField = 'injuriesid', //This is the fieldname for marker category (used in the pie and legend)
            // accident-type
            iconField = 'accidentid', //This is the fieldame for marker icon
            // accident-type, date and injuries
            popupFields = ['accidentid', 'dateevent', 'injuriesid'], //Popup will display these fields
            tileServer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            tileAttribution = 'Map data: <a href="http://openstreetmap.org">OSM</a>',
            rmax = 30, //Maximum radius for cluster pies
            markerclusters = L.markerClusterGroup({
                maxClusterRadius: 2 * rmax,
                iconCreateFunction: defineClusterIconAsBarChart //this is where the magic happens
            }),
            map = L.map('map').setView([59.95, 10.78], 8);

        //Add basemap
        L.tileLayer(tileServer, { attribution: tileAttribution, maxZoom: 15 }).addTo(map);
        //and the empty markercluster layer
        map.addLayer(markerclusters);

        //Ready to go, load the geojson
        d3.json(geojsonPath, function (error, data) {
            if (!error) {
                geojson = data;
                metadata = data.properties;
                var markers = L.geoJson(geojson, {
                    pointToLayer: defineFeature,
                    onEachFeature: defineFeaturePopup
                });
                markerclusters.addLayer(markers);
                map.fitBounds(markers.getBounds());
                map.attributionControl.addAttribution(metadata.attribution);
                //renderLegend()
                ;
            } else {
                console.log('Could not load data...');
            }
        });

        function defineFeature(feature, latlng) {
            var categoryVal = feature.properties[categoryField],
                iconVal = feature.properties[iconField];
            var myClass = 'marker category-' + categoryVal + ' icon-' + iconVal;
            var myIcon = L.divIcon({
                className: myClass,
                iconSize: null
            });
            return L.marker(latlng, { icon: myIcon });
        }

        function defineFeaturePopup(feature, layer) {
            var props = feature.properties,
                fields = metadata.fields,
                popupContent = '';

            popupFields.map(function (key) {
                if (props[key]) {
                    var val = props[key],
                        label = fields[key].name;
                    if (fields[key].lookup) {
                        val = fields[key].lookup[val];
                    }
                    popupContent += '<span class="attribute"><span class="label">' + label + ':</span> ' + val + '</span>';
                }
            });
            popupContent = '<div class="map-popup">' + popupContent + '</div>';
            layer.bindPopup(popupContent, { offset: L.point(1, -2) });
        }

        function defineClusterIcon1(cluster) {
            var children = cluster.getAllChildMarkers(),
                n = children.length, //Get number of markers in cluster
                strokeWidth = 1, //Set clusterpie stroke width
                r = rmax - 2 * strokeWidth - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
                iconDim = (r + strokeWidth) * 2, //...and divIcon dimensions (leaflet really want to know the size)
                data = d3.nest() //Build a dataset for the pie chart
                    .key(function (d) {
                        return d.feature.properties[categoryField];
                    })
                    // bind other values to the same chart
                    // .key(function (d) {
                    //     return d.feature.properties[iconField];
                    // })
                    .entries(children, d3.map),

                //bake some svg markup
                html = bakeBarChart({ //bakeThePie({
                    data: data,
                    valueFunc: function (d) {
                        // console.log('d.values.length: ', d.values.length);
                        return d.values.length;
                    },
                    strokeWidth: 1,
                    outerRadius: r,
                    innerRadius: r - 10,
                    pieClass: 'cluster-pie',
                    pieLabel: n,
                    pieLabelClass: 'marker-cluster-pie-label',
                    pathClassFunc: function (d) {
                        // console.log('d.data.key: ', d.data.key);
                        return "category-" + d.data.key;
                    },
                    pathTitleFunc: function (d) {
                        // console.log('metadata.fields[categoryField].lookup[d.data.key]: ', metadata.fields[categoryField].lookup[d.data.key]);
                        return metadata.fields[categoryField].lookup[d.data.key] + ' (' + d.data.values.length + ' accident' + (d.data.values.length != 1 ? 's' : '') + ')';
                    }
                }),
                //Create a new divIcon and assign the svg markup to the html property
                myIcon = new L.DivIcon({
                    html: html,
                    className: 'marker-cluster',
                    iconSize: new L.Point(iconDim, iconDim)
                });
            // console.log('myIcon: ' , myIcon);


            // console.log('defineClusterIcon data: ', data);
            return myIcon;
        }

        function defineClusterIconAsBarChart(cluster) {
            var children = cluster.getAllChildMarkers();
            var n = children.length,
                strokeWidth = 1;

            var dataset = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[categoryField];
                })
                .entries(children, d3.map);

            var r = 30 - 2 * 1 - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
                origo = (r + 1), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                iconDim = (r + 1) * 2;

            var valuesSummed = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[iconField];
                })
                .entries(children, d3.map);

            var data2 = [
                { "id": "1", "value": 1 },
                { "id": "2", "value": 2 },
                { "id": "3", "value": 3 }
            ];

            var x = d3.scaleBand().range([0, w]).padding(0.1);
            var y = d3.scaleLinear().range([h, 0]);

            x.domain(data2.map(function (d) { return d.id; }));
            y.domain([0, d3.max(data2, function (d) { return d.value; })]);

            // create a svg element
            var svg = document.createElementNS(d3.namespace.svg, 'svg');

            var vis = d3.select(svg)
                .attr("width", w)
                .attr("height", h)
                .append('g')
                .attr('transform', 'translate(' + (h / 200) + ',' + (w / 200) + ')'); //center g 

            vis.selectAll(".bar")
                .data(data2)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", function (d) {
                    return x(d.id);
                })
                .attr("width", x.bandwidth())
                .attr("y", function (d) { return y(d.value); })
                .attr("height", function (d) {
                    return h - y(d.id);
                });

            // add the x Axis
            vis.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + h + ")")
                .call(d3.axisBottom(x));

            // add the y Axis
            vis.append("g")
                .attr("class", "y axis")
                .call(d3.axisLeft(y));

            // var svg = dimple.newSvg("svg", w,h);
            // var chart = new dimple.chart(svg, data2);
            // chart.addCategoryAxis("x", "id");
            // chart.addMeasureAxis("y", "value");
            // chart.addSeries(null, dimple.plot.bar);
            // chart.draw();

            //console.log(svg);
            //console.log(svg2);

            var html = serializeXmlNode(svg);

            var myIcon = new L.DivIcon({
                html: html,
                className: 'mycluster',
                iconSize: new L.Point(iconDim, iconDim)
            });
            return myIcon;
        }

        function defineClusterIcon(cluster) {

            var color = d3.scale.category20b();
            //some dummy json
            var myjson = '[{ "label":"Monday", "count": 15 },{ "label":"Tuesday", "count": 20 }]';
            var dataset1 = JSON.parse(myjson);
            var children = cluster.getAllChildMarkers();
            var dataset = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[categoryField];
                })
                // bind other values to the same chart
                // .key(function (d) {
                //     return d.feature.properties[iconField];
                // })
                .entries(children, d3.map);
            var size = 35;
            var radius = size / 2;

            console.log('dataset1: ', dataset1);
            console.log('dataset: ', dataset);


            var svgres = document.createElementNS(d3.ns.prefix.svg, 'svg');
            var svg = d3.select(svgres).append('svg')
                .attr('width', size)
                .attr('height', size)
                .append('g')
                .attr('transform', 'translate(' + (size / 200) + ',' + (size / 200) + ')'); //center g 


            // trying to create bar chart
            // var strokeWidth = 1;
            // var n = children.length;
            // //var r = rmax - 2 * strokeWidth - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0);
            // var r = 10;
            // var origo = (r + strokeWidth), //Center coordinate
            //     w = origo * 2, //width and height of the svg element
            //     h = w;

            // var format = d3.format(",.0f");

            // var x = d3.scale.linear().range([0, w]),
            //     y = d3.scale.ordinal().rangeRoundBands([0, h], .1);

            // var xAxis = d3.svg.axis().scale(x).orient("top").tickSize(-h),
            //     yAxis = d3.svg.axis().scale(y).orient("left").tickSize(0);
            // x.domain([0, d3.max(dataset, function (d) {
            //     console.log(d);
            //     return d.key;
            // })]);
            // y.domain(dataset.map(function (d) { return d.length; }));



            // trying this )$(# again
            var bar = svg.selectAll("g.bar")
                .data(dataset1)
                .enter().append("g")
                .attr("class", "bar")
                .append("rect")
                .attr('x', function (d, i) {
                    return d.count
                })
                .attr('width', size)
                .attr('y', function (d) {
                    return d.label;
                })
                .attr('height', size);

            // bar.append("text")
            //     .attr("class", "value")
            //     .attr("x", function (d) { return x(d.length); })
            //     .attr("y", y.rangeBand() / 2)
            //     .attr("dx", -3)
            //     .attr("dy", ".35em")
            //     .attr("text-anchor", "end")
            //     .text(function (d) { return format(d.length); });

            // svg.append("g")
            //     .attr("class", "x axis")
            //     .call(xAxis);

            // svg.append("g")
            //     .attr("class", "y axis")
            //     .call(yAxis);


            // var arc = d3.svg.arc().outerRadius(radius);
            // var pie = d3.layout.pie().value(function (d) {
            //     return d.values.length;
            // });

            // //create final chart
            // var g = svg.selectAll('path').data(pie(dataset)) //fill dataset into path
            //     .enter() //create placeholder for data
            //     .append('path') //fill placeholder with data in path
            //     .attr('d', arc) //define an attribute d
            //     .attr('fill', function (d, i) {
            //         return color(d.data.key);
            //     });

            var html = serializeXmlNode(svgres);

            var myIcon = new L.DivIcon({
                html: html,
                className: 'mycluster',
                iconSize: new L.Point(size, size)
            });
            return myIcon;
        }

        /*function that generates a svg markup for the pie chart*/
        function bakeThePie(options) {
            /*data and valueFunc are required*/
            if (!options.data || !options.valueFunc) {
                return '';
            }
            var data = options.data,
                valueFunc = options.valueFunc,
                r = options.outerRadius ? options.outerRadius : 28, //Default outer radius = 28px
                rInner = options.innerRadius ? options.innerRadius : r - 10, //Default inner radius = r-10
                strokeWidth = options.strokeWidth ? options.strokeWidth : 1, //Default stroke is 1
                pathClassFunc = options.pathClassFunc ? options.pathClassFunc : function () {
                    return '';
                }, //Class for each path
                pathTitleFunc = options.pathTitleFunc ? options.pathTitleFunc : function () {
                    return '';
                }, //Title for each path
                pieClass = options.pieClass ? options.pieClass : 'marker-cluster-pie', //Class for the whole pie
                pieLabel = options.pieLabel ? options.pieLabel : d3.sum(data, valueFunc), //Label for the whole pie
                pieLabelClass = options.pieLabelClass ? options.pieLabelClass : 'marker-cluster-pie-label',//Class for the pie label

                origo = (r + strokeWidth), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                donut = d3.layout.pie(),
                arc = d3.svg.arc().innerRadius(rInner).outerRadius(r);


            // entender como distribuir os valores aqui
            // console.log('data: ' , data);
            // console.log('valueFunc: ' , valueFunc);
            //Create an svg element
            var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
            //Create the pie chart
            var vis = d3.select(svg)
                .data([data])
                .attr('class', pieClass)
                .attr('width', w)
                .attr('height', h);

            // console.log('svg: ' , svg);
            // console.log('arc: ' , arc);

            var arcs = vis.selectAll('g.arc')
                .data(donut.value(valueFunc))
                .enter().append('svg:g')
                .attr('class', 'arc')
                .attr('transform', 'translate(' + origo + ',' + origo + ')');
            // console.log('arcs: ' , arcs);

            // console.log('origo: ' , origo);
            arcs.append('svg:path')
                .attr('class', pathClassFunc)
                .attr('stroke-width', strokeWidth)
                .attr('d', arc)
                .append('svg:title')
                .text(pathTitleFunc);

            vis.append('text')
                .attr('x', origo)
                .attr('y', origo)
                .attr('class', pieLabelClass)
                .attr('text-anchor', 'middle')
                //.attr('dominant-baseline', 'central')
                /*IE doesn't seem to support dominant-baseline, but setting dy to .3em does the trick*/
                .attr('dy', '.3em')
                .text(pieLabel);
            //Return the svg-markup rather than the actual element

            console.log('svg: ', svg);
            return serializeXmlNode(svg);
        }

        function bakeBarChart(options) {
            /*data and valueFunc are required*/
            if (!options.data || !options.valueFunc) {
                return '';
            }
            var data = options.data,
                valueFunc = options.valueFunc,
                r = options.outerRadius ? options.outerRadius : 28, //Default outer radius = 28px
                rInner = options.innerRadius ? options.innerRadius : r - 10, //Default inner radius = r-10
                strokeWidth = options.strokeWidth ? options.strokeWidth : 1, //Default stroke is 1
                pathClassFunc = options.pathClassFunc ? options.pathClassFunc : function () {
                    return '';
                }, //Class for each path
                pathTitleFunc = options.pathTitleFunc ? options.pathTitleFunc : function () {
                    return '';
                }, //Title for each path
                pieClass = options.pieClass ? options.pieClass : 'marker-cluster-pie', //Class for the whole pie
                pieLabel = options.pieLabel ? options.pieLabel : d3.sum(data, valueFunc), //Label for the whole pie
                pieLabelClass = options.pieLabelClass ? options.pieLabelClass : 'marker-cluster-pie-label',//Class for the pie label

                origo = (r + strokeWidth), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                donut = d3.layout.pie(),
                arc = d3.svg.arc().innerRadius(rInner).outerRadius(r);


            // entender como distribuir os valores aqui
            // console.log('data: ' , data);
            // console.log('valueFunc: ' , valueFunc);
            //Create an svg element
            var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
            //Create the pie chart
            // var vis1 = d3.select(svg)
            //     .data([data])
            //     .attr('class', pieClass)
            //     .attr('width', w)
            //     .attr('height', h);

            var vis = d3.select(svg)
                .data([data])
                .attr('class', 'barchart')
                .attr('width', w)
                .attr('height', h);

            // console.log('svg: ' , svg);
            console.log('pathClassFunc: ', pathClassFunc);

            var arcs = vis.selectAll('g.arc')
                .data(donut.value(valueFunc))
                .enter().append('svg:g')
                .attr('class', 'arc')
                .attr('transform', 'translate(' + origo + ',' + origo + ')');
            // console.log('arcs: ' , arcs);

            // console.log('origo: ' , origo);
            arcs.append('svg:path')
                .attr('class', pathClassFunc)
                .attr('stroke-width', strokeWidth)
                .attr('d', arc)
                .append('svg:title')
                .text(pathTitleFunc);

            vis.append('text')
                .attr('x', origo)
                .attr('y', origo)
                .attr('class', pieLabelClass)
                .attr('text-anchor', 'middle')
                //.attr('dominant-baseline', 'central')
                /*IE doesn't seem to support dominant-baseline, but setting dy to .3em does the trick*/
                .attr('dy', '.3em')
                .text(pieLabel);
            //Return the svg-markup rather than the actual element
            return serializeXmlNode(svg);
        }

        /*Function for generating a legend with the same categories as in the clusterPie*/
        function renderLegend() {
            var data = d3.entries(metadata.fields[categoryField].lookup),
                legenddiv = d3.select('body').append('div')
                    .attr('id', 'legend');

            var heading = legenddiv.append('div')
                .classed('legendheading', true)
                .text(metadata.fields[categoryField].name);

            var legenditems = legenddiv.selectAll('.legenditem')
                .data(data);

            legenditems
                .enter()
                .append('div')
                .attr('class', function (d) {
                    return 'category-' + d.key;
                })
                .classed({ 'legenditem': true })
                .text(function (d) {
                    return d.value;
                });
        }

        /*Helper function*/
        function serializeXmlNode(xmlNode) {
            if (typeof window.XMLSerializer != "undefined") {
                return (new window.XMLSerializer()).serializeToString(xmlNode);
            } else if (typeof xmlNode.xml != "undefined") {
                return xmlNode.xml;
            }
            return "";
        }

    </script>
<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Crossfilter Geo Test</title>
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.css"/>
    <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/MarkerCluster.css'
          rel='stylesheet'/>
    <link rel="stylesheet" href="clusterpies.css"/>
    <link rel="stylesheet" href="https://npmcdn.com/leaflet@0.7.7/dist/leaflet.css">
    <link rel="stylesheet" href="https://dc-js.github.io/dc.js/css/dc.min.css">
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <style>

        #map {
            height: 425px;
            width: 100%;
            margin: 0 auto;
        }

        #mag-chart {
            width: 100%;
            margin: 0 auto;
        }

        #date-chart {
            width: 100%;
            margin: 0 auto;
        }

        .dc-data-count {
            width: 100%;
            height: 60px;
        }

    </style>

</head>

<body>
<div class="container">
    <h2>dc.js + crossfilter with Leaflet Map as Filter Input</h2>

    <div class="row">
        <div class="col-md-4">
            <div class="dc-data-count"></div>
            <h4>Count by Magnitude</h4>
            <div id="mag-chart"></div>
            <h4>Count by Depth(m)</h4>
            <div id="depth-chart"></div>
        </div>
        <div class="col-md-8">
            <div id="map"></div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12">
            <h4>Count by Day</h4>
            <div id="date-chart"></div>
        </div>
    </div>
</div>

<script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js" charset="utf-8"></script>
<script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js'></script>
<!--<script src="https://dc-js.github.io/dc.js/js/d3.js"></script>-->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="https://dc-js.github.io/dc.js/js/crossfilter.js"></script>
<script src="https://dc-js.github.io/dc.js/js/dc.js"></script>
<!--<script src="https://npmcdn.com/leaflet@0.7.7/dist/leaflet.js"></script>-->
<!-- <script src="//api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js"></script> -->
<script src="turf.min.js"></script>
<script>

    "use strict"
    var geojson,
        metadata,
        geojsonPath = 'traffic_accidents.geojson',
        // injuries
        categoryField = 'injuriesid', //This is the fieldname for marker category (used in the pie and legend)
        // accident-type
        iconField = 'accidentid', //This is the fieldame for marker icon
        // accident-type, date and injuries
        popupFields = ['accidentid', 'dateevent', 'injuriesid'], //Popup will display these fields
        tileServer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        tileAttribution = 'Map data: <a href="http://openstreetmap.org">OSM</a>',
        rmax = 30, //Maximum radius for cluster pies
        markerclusters = L.markerClusterGroup({
            maxClusterRadius: 2 * rmax,
            iconCreateFunction: defineClusterIcon //this is where the magic happens
        }),
        map = L.map('map').setView([59.95, 10.78], 8);


    //L.tileLayer('http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://carto.com/attributions">CARTO</a>'})
      //  .addTo(map);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);

    map.addLayer(markerclusters);


    //    d3.json('earthquakes.geojson', function (data) {
    d3.json('traffic_accidents.geojson', function (error, data) {

        if (!error) {

            // donut map
            geojson = data;
            metadata = data.properties;
            var markers = L.geoJson(geojson, {
                pointToLayer: defineFeature,
                onEachFeature: defineFeaturePopup
            });
            markerclusters.addLayer(markers);
            map.fitBounds(markers.getBounds());
            map.attributionControl.addAttribution(metadata.attribution);
            renderLegend();

            //create crossfilter and dimensions
            var filter = crossfilter(data.features)
            var all = filter.groupAll();
            var everything = filter.dimension(function (d) {
                return d
            })

            var geomDimension = filter.dimension(function (d) {
                return d.geometry
            })

            var magDimension = filter.dimension(function (d) {
                var mag = d.properties['injuriesid']
//            return mag < 1.5 ? '1-1.5' :
//                mag < 2 ? '1.5-2' :
//                mag < 2.5 ? '2-2.5' :
//                mag < 3 ? '2.5-3' : '>3'
                return mag < 2.5 ? '2-2.5' :
                    mag < 3.5 ? '2.4-3.5' :
                        mag < 4.5 ? '3.5-4.5' :
                            mag < 5.5 ? '4.5-5.5' : '>5.5'
            })
            var magDimensionGroup = magDimension.group()


            var depthDimension = filter.dimension(function (d) {
                var depth = d.properties['accidentid']
//            return (depth < 5) ? ' <5' :
//                depth < 10 ? ' 5-10' :
//                    depth < 50 ? '10-50' :
//                        depth < 100 ? '50-100' :
//                            '>100'
                return (depth < 1) ? ' <1' :
                    depth < 2 ? ' 1-2' :
                        depth < 3 ? '2-3' :
                            depth < 4 ? '3-4' : '>4'


            });
            var depthDimensionGroup = depthDimension.group()

            var dateDimension = filter.dimension(function (d) {

                return d3.time.day(new Date(d.properties['dateevent']))
            })

            var dateDimensionGroup = dateDimension.group()

            //add the data to the map
            // this point is adding the markers to the map
            // geoJsonLayer is used to bing the charts to the map
            var geoJsonLayer = L.geoJson({
                type: 'FeatureCollection',
                features: geomDimension.top(Infinity)
            }, {
                pointToLayer: function (feature, latlng) {
                    return L.circleMarker(latlng, {
                        radius: 4,
                        fillColor: "steelblue",
                        color: "#fff",
                        weight: 1,
                        opacity: 1,
                        fillOpacity: 0.8
                    })
                        .bindPopup(feature.properties['injuriesid'].toString());
                }
            }).addTo(map);

            //create charts
            var magChart = dc.barChart('#mag-chart')

            magChart

                .height(180)
                .margins({top: 10, right: 50, bottom: 30, left: 40})
                .dimension(magDimension)
                .group(magDimensionGroup)
                .elasticY(true)
                .x(d3.scale.ordinal())
                .xUnits(dc.units.ordinal)
                .yAxis()
                .ticks(3)


            var depthChart = dc.barChart('#depth-chart')

            depthChart

                .height(180)
                .margins({top: 10, right: 50, bottom: 30, left: 40})
                .dimension(depthDimension)
                .group(depthDimensionGroup)
                .elasticY(true)
                .x(d3.scale.ordinal())
                .xUnits(dc.units.ordinal)
                .yAxis()
                .ticks(3)


            var dateChart = dc.lineChart('#date-chart')
            dateChart
                .renderArea(true)
                .height(200)
                .transitionDuration(1000)
                .margins({top: 30, right: 50, bottom: 25, left: 40})
                .dimension(dateDimension)
                .group(dateDimensionGroup)
                .elasticY(true)
                .x(d3.time.scale().domain([new Date(2016, 7, 1), new Date(2016, 8, 1)]))
                .xUnits(d3.time.days)


            var earthquakeCount = dc.dataCount('.dc-data-count');
            earthquakeCount
                .dimension(filter)
                .group(all)
                .html({
                    some: '<strong>%filter-count</strong> selected out of <strong>%total-count</strong> records' +
                    ' | <a href=\'javascript:dc.filterAll(); dc.renderAll();\'>Reset All</a>',
                    all: 'All records selected. Please click on the graph or change the map view to apply filters.'
                });

            dc.renderAll();

            //chart listeners

            magChart.on('filtered', function (chart, filter) {
                updateMap()
            })

            depthChart.on('filtered', function (chart, filter) {
                updateMap()
            })

            dateChart.on('filtered', function (chart, filter) {
                updateMap()
            })

            function updateMap() {
                geoJsonLayer.clearLayers()
                geoJsonLayer.addData({
                    type: 'FeatureCollection',
                    features: everything.top(Infinity)
                })
            }

            //map listeners
            map.on('moveend', function () {
                updateMapFilter()
            })

            map.on('zoomend', function () {
                updateMapFilter()
            })

            function updateMapFilter() {

                var bounds = map.getBounds(),
                    n = bounds._northEast.lat,
                    e = bounds._northEast.lng,
                    s = bounds._southWest.lat,
                    w = bounds._southWest.lng;

                var boundsFeature = {
                    type: 'Feature',
                    geometry: {
                        type: 'Polygon',
                        coordinates: [
                            [
                                [
                                    w,
                                    s
                                ],
                                [
                                    w,
                                    n
                                ],
                                [
                                    e,
                                    n
                                ],
                                [
                                    e,
                                    s
                                ],
                                [
                                    w,
                                    s
                                ]
                            ]
                        ]
                    }
                }

                geomDimension.filter(function (d) {
                    //make feature
                    var point = {
                        type: 'Feature',
                        geometry: d
                    }

                    return turf.inside(point, boundsFeature)
                })

                dc.redrawAll();
            }

        } else {
            console.log('Could not load data...');
        }

    })

    function defineClusterIcon(cluster) {
        var children = cluster.getAllChildMarkers(),
            n = children.length, //Get number of markers in cluster
            strokeWidth = 1, //Set clusterpie stroke width
            r = rmax - 2 * strokeWidth - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
            iconDim = (r + strokeWidth) * 2, //...and divIcon dimensions (leaflet really want to know the size)
            data = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[categoryField];
                })
                .entries(children, d3.map),
            //bake some svg markup
            html = bakeThePie({
                data: data,
                valueFunc: function (d) {
                    return d.values.length;
                },
                strokeWidth: 1,
                outerRadius: r,
                innerRadius: r - 10,
                pieClass: 'cluster-pie',
                pieLabel: n,
                pieLabelClass: 'marker-cluster-pie-label',
                pathClassFunc: function (d) {
                    return "category-" + d.data.key;
                },
                pathTitleFunc: function (d) {
                    return metadata.fields[categoryField].lookup[d.data.key] + ' (' + d.data.values.length + ' accident' + (d.data.values.length != 1 ? 's' : '') + ')';
                }
            }),
            //Create a new divIcon and assign the svg markup to the html property
            myIcon = new L.DivIcon({
                html: html,
                className: 'marker-cluster',
                iconSize: new L.Point(iconDim, iconDim)
            });
        return myIcon;
    }

    function renderLegend() {
        var data = d3.entries(metadata.fields[categoryField].lookup),
            legenddiv = d3.select('body').append('div')
                .attr('id', 'legend');

        var heading = legenddiv.append('div')
            .classed('legendheading', true)
            .text(metadata.fields[categoryField].name);

        var legenditems = legenddiv.selectAll('.legenditem')
            .data(data);

        legenditems
            .enter()
            .append('div')
            .attr('class', function (d) {
                return 'category-' + d.key;
            })
            .classed({'legenditem': true})
            .text(function (d) {
                return d.value;
            });
    }

    /*Helper function*/
    function serializeXmlNode(xmlNode) {
        if (typeof window.XMLSerializer != "undefined") {
            return (new window.XMLSerializer()).serializeToString(xmlNode);
        } else if (typeof xmlNode.xml != "undefined") {
            return xmlNode.xml;
        }
        return "";
    }

    /*function that generates a svg markup for the pie chart*/
    function bakeThePie(options) {
        /*data and valueFunc are required*/
        if (!options.data || !options.valueFunc) {
            return '';
        }
        var data = options.data,
            valueFunc = options.valueFunc,
            r = options.outerRadius ? options.outerRadius : 8, //Default outer radius = 28px
            rInner = options.innerRadius ? options.innerRadius : r - 10, //Default inner radius = r-10
            strokeWidth = options.strokeWidth ? options.strokeWidth : 1, //Default stroke is 1
            pathClassFunc = options.pathClassFunc ? options.pathClassFunc : function () {
                return '';
            }, //Class for each path
            pathTitleFunc = options.pathTitleFunc ? options.pathTitleFunc : function () {
                return '';
            }, //Title for each path
            pieClass = options.pieClass ? options.pieClass : 'marker-cluster-pie', //Class for the whole pie
            pieLabel = options.pieLabel ? options.pieLabel : d3.sum(data, valueFunc), //Label for the whole pie
            pieLabelClass = options.pieLabelClass ? options.pieLabelClass : 'marker-cluster-pie-label',//Class for the pie label

            origo = (r + strokeWidth), //Center coordinate
            w = origo * 2, //width and height of the svg element
            h = w,
            donut = d3.layout.pie(),
            arc = d3.svg.arc().innerRadius(rInner).outerRadius(r);

        //console.log(pieClass);
        //console.log(pieLabel);
        //console.log(pieLabelClass);

        //Create an svg element
        var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
        //Create the pie chart
        var vis = d3.select(svg)
            .data([data])
            .attr('class', pieClass)
            .attr('width', w)
            .attr('height', h);

        var arcs = vis.selectAll('g.arc')
            .data(donut.value(valueFunc))
            .enter().append('svg:g')
            .attr('class', 'arc')
            .attr('transform', 'translate(' + origo + ',' + origo + ')');

        arcs.append('svg:path')
            .attr('class', pathClassFunc)
            .attr('stroke-width', strokeWidth)
            .attr('d', arc)
            .append('svg:title')
            .text(pathTitleFunc);

        vis.append('text')
            .attr('x', origo)
            .attr('y', origo)
            .attr('class', pieLabelClass)
            .attr('text-anchor', 'middle')
            //.attr('dominant-baseline', 'central')
            /*IE doesn't seem to support dominant-baseline, but setting dy to .3em does the trick*/
            .attr('dy', '.3em')
            .text(pieLabel);
        //Return the svg-markup rather than the actual element
        return serializeXmlNode(svg);
    }
    function defineFeature(feature, latlng) {
        var categoryVal = feature.properties[categoryField],
            iconVal = feature.properties[iconField];
        //console.log('iconVal: ' , iconVal);
        var myClass = 'marker category-' + categoryVal + ' icon-' + iconVal;
        var myIcon = L.divIcon({
            className: myClass,
            iconSize: null
        });
        return L.marker(latlng, {icon: myIcon});
    }

    function defineFeaturePopup(feature, layer) {
        var props = feature.properties,
            fields = metadata.fields,
            popupContent = '';
        //console.log('feature: ', feature);
        //console.log('layer: ', layer);

        popupFields.map(function (key) {
            //console.log('key: ', key);
            if (props[key]) {
                var val = props[key],
                    label = fields[key].name;
                //console.log('val: ', val);
                if (fields[key].lookup) {
                    val = fields[key].lookup[val];
                    //console.log('val 2: ', val);
                }
                popupContent += '<span class="attribute"><span class="label">' + label + ':</span> ' + val + '</span>';
            }
        });
        popupContent = '<div class="map-popup">' + popupContent + '</div>';
        layer.bindPopup(popupContent, {offset: L.point(1, -2)});
    }


</script>
</body>
</html>